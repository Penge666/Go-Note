原仓库链接：https://github.com/Camio1945/mini-container

这个 Go 代码的主要作用是实现一个**简化版的容器**，通过使用 Linux 的 `chroot` 和 `cgroup` 机制，实现了一个基本的进程隔离和资源限制环境。以下是逐步解析代码所做的事情：

------

### 1. **cgroup（控制组）资源限制**

- 程序在 `/sys/fs/cgroup/pids` 目录下创建了一个新的 cgroup 控制组 (`liz`)。
- **目的**：限制容器中的进程数量，最多只能运行 20 个进程。
- 实现：
  - `pids.max`: 设置最大进程数为 20。
  - `notify_on_release`: 当容器退出时自动清理 cgroup。
  - `cgroup.procs`: 将当前进程（容器的主进程）的 PID 写入 cgroup。

✅ **效果**：容器内无法创建超过 20 个进程，防止资源滥用。

------

### 2. **文件系统隔离（chroot）**

- 使用 `chroot` 将根目录更改为 `/home/liz/ubuntufs`，这个目录成为容器的“根目录”。
- **chroot** 的作用是让进程“看不到”宿主机的真实文件系统，增强隔离性。

✅ **效果**：容器内只能访问 `/home/liz/ubuntufs` 目录，无法直接访问宿主机的其他文件。

------

### 3. **挂载虚拟文件系统**

- 挂载了 proc 和 tmpfs：
  - `proc`：用于显示进程信息，容器内部需要它来查看进程相关信息（如 `/proc` 下的文件）。
  - `tmpfs`：挂载点为 `mytemp`，是一个临时的内存文件系统，用于创建临时文件。

✅ **效果**：提供了一个基本的、受限的 Linux 文件系统环境，使容器能够正常运行。

------

### 4. **命令执行**

- 通过 `exec.Command()` 执行用户传递的命令，例如 `/bin/bash`。
- **命令继承了标准输入输出**，确保用户能够与容器交互。

✅ **效果**：用户在容器中能够运行任意命令（如 bash），但受 cgroup 和 `chroot` 限制。

------

### 5. **清理挂载**

- 使用 `syscall.Unmount()` 在程序退出时清理挂载的 `proc` 和 `tmpfs`。

✅ **效果**：防止资源泄漏，确保容器退出后系统恢复原状。



**总结：这个 Go 代码实现了一个简单的容器原理：**

1. **资源限制**：用 `cgroup` 限制最多 20 个进程。
2. **文件系统隔离**：用 `chroot` 将根目录改为 `/home/liz/ubuntufs`。
3. **挂载必要的文件系统**：如 `proc` 和 `tmpfs`。
4. **命令执行**：在容器中运行用户传递的命令（如 `/bin/bash`）。
5. **清理机制**：在退出时卸载挂载点，释放资源。

